This challenge was really interesting!

After examining the binary, the first thing I noticed was:

LoadLibraryA("C:\\Users\\Huynh Quoc Ky\\Downloads\\Ransomware\\libgen.dll");
It also opens a file named anonymous, but without more information, I decided to move on and analyze the functions further.
Soon, I found this line:

Stream = fopen("C:\\ProgramData\\Important\\user.html", "rb");
This is likely where the stolen user data is stored.
I also discovered a function that tries to encrypt user.html using RC4, with the encryption key being generated by a function inside libgen.dll, which, as mentioned earlier, is dynamically loaded.

After encryption, it sends the file user.html.enc to a remote server.
The binary sends the length of the file first, followed by the actual encrypted content.

When I inspected the provided .pcap file, I noticed that packet 18 contains the file length (4 bytes), and packets 19 and 20 contain the encrypted contents of the file.

So, my first goal was to find the RC4 key used to encrypt user.html.enc.
To do that, I needed the file libgen.dll.

As I continued analyzing the binary, I found that it encrypts libgen.dll using the key:

sha256("hackingisnotacrime")
The encrypted file is saved as hacker and then uploaded to the server — which is unusual behavior for malware, by the way. :)

After consulting ChatGPT (lol), I concluded the encryption algorithm used was AES-256-ECB.

Looking back at the .pcap, I found that:

Packet 29 contains the length of the file.

Packets 30 to 38 contain the actual encrypted data.

This seemed to be the encrypted libgen.dll, so I extracted it in raw form and decrypted it using AES-256-ECB with the derived key.
That gave me the original libgen.dll file.

I then placed it back into:

C:\\Users\\Huynh Quoc Ky\\Downloads\\Ransomware\\libgen.dll
With the DLL loaded, I began debugging and set a breakpoint right after the key generation function.
The encryption key is stored in the memory address held in the RAX register.
(You’ll need to bypass anti-debugging mechanisms here — it's fairly straightforward.)

Great! Now that we have the key, we can decrypt user.html.enc and retrieve the flag!